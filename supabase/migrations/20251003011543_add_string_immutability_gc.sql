/*
  # Add String Immutability and Garbage Collector
  
  Deep explanations for C# fundamentals
*/

DO $$
DECLARE
  cat_oop uuid;
  current_term_id uuid;
BEGIN
  SELECT id INTO cat_oop FROM categories WHERE slug = 'oop';

  -- String Immutability
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_oop, 'String Immutability',
    'Strings cannot be changed once created. Every "modification" creates NEW string. Original unchanged.',
    'String immutability: string objects cannot be modified after creation. Any operation that appears to modify string actually creates new string object.',
    'In C#/Java, strings are immutable. When you "modify" string, you create new object. Original unchanged. Why? Thread safety, security (can''t change after validation), performance (string pooling, hash code caching). Use StringBuilder for many concatenations.',
    to_jsonb(ARRAY['String concatenation in loops (slow)', 'Not understanding new string created', 'Security implications ignored', 'Not using StringBuilder when needed']),
    jsonb_build_object(
      'csharp', E'// String Immutability demonstration\nstring original = "Hello";\nstring modified = original;\n\nmodified = "World"; // Creates NEW string\n\nConsole.WriteLine(original); // "Hello" (UNCHANGED!)\nConsole.WriteLine(modified); // "World" (NEW object)\n\n// Every operation creates NEW string\nstring s = "Hello";\ns = s + " World";  // Creates NEW string "Hello World"\ns = s.ToUpper();   // Creates NEW string "HELLO WORLD"\ns = s.Replace("WORLD", "THERE"); // Creates NEW "HELLO THERE"\n// Each line: new string object!\n\n// Problem: String concatenation in loop (BAD)\nstring result = "";\nfor(int i = 0; i < 10000; i++) {\n  result += i.ToString(); // Creates 10000 NEW strings! O(n²)\n}\n// Each += creates new string, copies all previous chars\n// Very slow!\n\n// Solution: StringBuilder (GOOD)\nvar sb = new StringBuilder();\nfor(int i = 0; i < 10000; i++) {\n  sb.Append(i); // Modifies internal buffer, no new objects\n}\nstring result = sb.ToString(); // Only 1 new string at end\n// Much faster! O(n)\n\n// Why immutability matters\n\n// 1. Thread Safety\nstring shared = "Thread Safe";\n// Multiple threads can read safely\n// No thread can modify original\n\n// 2. Security\nstring password = GetPassword();\nif(ValidatePassword(password)) {\n  // password string CAN\'T be changed after validation\n  // Immutability prevents tampering\n}\n\n// 3. Hash code consistency\nDictionary<string, int> dict = new();\nstring key = "myKey";\ndict[key] = 100;\n\n// If strings were mutable:\n// key = "changed"; // Would break dictionary!\n// But strings immutable, so safe\n\n// 4. String pooling (interning)\nstring s1 = "Hello";\nstring s2 = "Hello";\n\nConsole.WriteLine(Object.ReferenceEquals(s1, s2)); // true!\n// Both reference SAME object in string pool\n// Only possible because immutable\n\n// Proof of new string creation\nstring a = "Hello";\nstring b = a;\nConsole.WriteLine(Object.ReferenceEquals(a, b)); // true (same reference)\n\na = a + " World";\nConsole.WriteLine(Object.ReferenceEquals(a, b)); // false! (different objects)\nConsole.WriteLine(b); // "Hello" (unchanged)\n\n// StringBuilder vs String\nstring str = "a";\nfor(int i = 0; i < 3; i++) {\n  str += "b"; // Creates: "a", "ab", "abb", "abbb"\n}\n// 4 string objects created!\n\nStringBuilder sb2 = new("a");\nfor(int i = 0; i < 3; i++) {\n  sb2.Append("b"); // Modifies buffer in place\n}\nstring final = sb2.ToString(); // "abbb" - 2 total objects (buffer + final)\n\n// When to use each\n// String: few operations, simple concatenation\nstring greeting = "Hello" + " " + name; // OK\n\n// StringBuilder: many operations, loops\nvar builder = new StringBuilder();\nforeach(var item in items) {\n  builder.Append(item);\n  builder.Append(", ");\n}\nstring list = builder.ToString();',
      'typescript', E'// JavaScript strings also immutable\nlet original = "Hello";\nlet modified = original;\n\nmodified = "World"; // New string\n\nconsole.log(original); // "Hello" (unchanged)\nconsole.log(modified); // "World"\n\n// Every operation creates new string\nlet s = "Hello";\ns = s + " World";     // New string\ns = s.toUpperCase();  // New string\ns = s.replace("WORLD", "THERE"); // New string\n\n// String concatenation in loop (less efficient)\nlet result = "";\nfor(let i = 0; i < 10000; i++) {\n  result += i; // Creates many strings\n}\n\n// Better: array join\nconst parts: string[] = [];\nfor(let i = 0; i < 10000; i++) {\n  parts.push(i.toString());\n}\nconst result = parts.join(""); // One final string\n\n// Or template literals\nconst name = "John";\nconst greeting = `Hello ${name}!`; // Creates one new string\n\n// Immutability in practice\nconst password = "secret123";\n// Can\'t do: password[0] = ''S''; // Error in strict mode\n// Strings can\'t be modified\n\n// String interning (concept)\nconst s1 = "hello";\nconst s2 = "hello";\n// In some engines, s1 and s2 point to same memory\n// Possible because immutable'
    ),
    E'String Immutability:\n\nstring s = "Hello";\ns = s + " World";\n\n[Memory]\n"Hello" ← s (original)\n         ↓ (new object)\n"Hello World" ← s (after +=)\n\nOriginal "Hello" unchanged!\nEvery operation = NEW string\n\nString Pool:\n  ["Hello"] ← s1, s2 (shared)\n  ["World"] ← s3\n  Immutable → safe sharing\n\nStringBuilder:\n  [Mutable Buffer] → grow in place\n  .ToString() → final string\n  \nUse for loops/many operations',
    127
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'Strings are?', to_jsonb(ARRAY['Mutable', 'Immutable (cannot change)', 'Sometimes mutable', 'Depends']), 1, 'Cannot modify after creation.'),
    (current_term_id, 'String concatenation creates?', to_jsonb(ARRAY['Modifies original', 'New string object', 'Nothing', 'Error']), 1, 'Every operation = new object.'),
    (current_term_id, 'Why string immutability?', to_jsonb(ARRAY['No reason', 'Thread safety, security, performance (pooling)', 'Slower', 'Easier']), 1, 'Multiple benefits.'),
    (current_term_id, 'String += in loop?', to_jsonb(ARRAY['Efficient', 'Inefficient, creates many objects', 'Best practice', 'Fast']), 1, 'O(n²) complexity.'),
    (current_term_id, 'StringBuilder for?', to_jsonb(ARRAY['Single concatenation', 'Many string operations in loop', 'Nothing', 'Security']), 1, 'Mutable buffer, efficient.'),
    (current_term_id, 'String pooling possible because?', to_jsonb(ARRAY['Mutable', 'Immutable - safe to share same object', 'Fast', 'Security']), 1, 'Multiple variables can reference same string safely.');

  -- Garbage Collector
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_oop, 'Garbage Collector (GC)',
    'Automatic memory manager. Finds unused objects and frees memory. You don''t manually delete like C++.',
    'Garbage Collector: automatic memory management system that reclaims memory occupied by unreachable objects. Runs periodically, traces object references, collects garbage.',
    '.NET has automatic GC. You create objects with "new", GC cleans up when no longer referenced. Generational: Gen 0 (young), Gen 1 (middle), Gen 2 (old survivors). GC pauses app briefly (stop-the-world). Dispose pattern for unmanaged resources (files, DB connections).',
    to_jsonb(ARRAY['Relying on GC for unmanaged resources', 'Not understanding GC pauses', 'Memory leaks from event handlers', 'Not implementing IDisposable when needed', 'Forcing GC.Collect() unnecessarily']),
    jsonb_build_object(
      'csharp', E'// Garbage Collector basics\n\n// Creating objects\npublic void CreateObjects() {\n  var obj1 = new MyClass(); // Allocated on heap\n  var obj2 = new MyClass();\n  var obj3 = new MyClass();\n  \n  // When method exits:\n  // obj1, obj2, obj3 out of scope → no more references\n  // GC will collect them eventually\n} // obj1, obj2, obj3 eligible for collection\n\n// Object references\npublic class Person {\n  public string Name { get; set; }\n}\n\nPerson p1 = new Person { Name = "John" };\nPerson p2 = p1; // Both reference same object\n\np1 = null; // p1 no longer references\n// Object still alive because p2 references it\n\np2 = null; // Now NO references\n// Object eligible for GC\n\n// Generational GC\n// Gen 0: Newly created objects (frequent collection)\n// Gen 1: Survived one GC (less frequent)\n// Gen 2: Long-lived objects (rare collection)\n\n// Example\nvar temp = new byte[1000]; // Gen 0\n// GC runs\n// If temp survives → Gen 1\n// GC runs again\n// If still alive → Gen 2\n\n// IDisposable for unmanaged resources\npublic class FileManager : IDisposable {\n  private FileStream file;\n  \n  public FileManager(string path) {\n    file = File.OpenRead(path); // Unmanaged resource\n  }\n  \n  public void Dispose() {\n    // Explicitly release unmanaged resource\n    file?.Dispose();\n    file = null;\n    \n    // Tell GC not to finalize\n    GC.SuppressFinalize(this);\n  }\n}\n\n// Using pattern (automatic disposal)\nusing(var manager = new FileManager("data.txt")) {\n  // Use manager\n} // Dispose() called automatically\n\n// Or with using declaration (C# 8)\nusing var manager2 = new FileManager("data.txt");\n// Dispose() called at end of scope\n\n// Memory leak example: Event handlers\npublic class Publisher {\n  public event EventHandler MyEvent;\n}\n\npublic class Subscriber {\n  public Subscriber(Publisher pub) {\n    pub.MyEvent += OnEvent; // Creates reference!\n  }\n  \n  private void OnEvent(object sender, EventArgs e) { }\n  \n  // PROBLEM: Publisher holds reference to Subscriber\n  // Even if Subscriber out of scope elsewhere\n  // Subscriber NOT collected → memory leak!\n  \n  // Solution: Unsubscribe\n  public void Cleanup(Publisher pub) {\n    pub.MyEvent -= OnEvent; // Remove reference\n  }\n}\n\n// GC methods (rarely needed)\nGC.Collect(); // Force collection (DON\'T use in production)\nGC.WaitForPendingFinalizers();\n\nlong memory = GC.GetTotalMemory(false); // Get memory usage\n\n// Best practices:\n// 1. Let GC do its job (don\'t force collect)\n// 2. Implement IDisposable for unmanaged resources\n// 3. Use \'using\' for IDisposable objects\n// 4. Unsubscribe event handlers\n// 5. Avoid large object allocations (>85KB)\n\n// Finalizer (destructor) - rare\npublic class ResourceHolder {\n  ~ResourceHolder() { // Finalizer\n    // Called by GC before collection\n    // Cleanup unmanaged resources\n    // DON\'T use for managed resources!\n  }\n}\n// Note: Finalizers slow down GC\n// Prefer IDisposable\n\n// Large Object Heap (LOH)\nbyte[] small = new byte[1000];     // Regular heap\nbyte[] large = new byte[100_000];  // Large Object Heap (≥85KB)\n// LOH collected less frequently\n// Can cause fragmentation',
      'typescript', E'// JavaScript also has Garbage Collection\n// Similar concepts, automatic\n\nlet obj1 = { name: "John" };\nlet obj2 = obj1; // Both reference same object\n\nobj1 = null; // obj1 no reference\n// Object still alive (obj2 references it)\n\nobj2 = null; // No references\n// Object eligible for GC\n\n// Memory leak: Event listeners\nconst button = document.querySelector(''button'');\nconst handler = () => console.log(''clicked'');\n\nbutton.addEventListener(''click'', handler);\n// Button holds reference to handler\n\n// If handler references large object:\nconst data = new Array(1000000);\nconst leakyHandler = () => console.log(data.length);\nbutton.addEventListener(''click'', leakyHandler);\n// data can\'t be collected (referenced by handler)\n\n// Solution: Remove listener\nbutton.removeEventListener(''click'', leakyHandler);\n// Now data can be collected\n\n// Circular references (old IE problem, modern GC handles)\nconst objA = {};\nconst objB = {};\nobjA.ref = objB;\nobjB.ref = objA;\n// Modern GC: mark-and-sweep finds circular garbage\n\n// Weak references (avoid memory leaks)\nconst cache = new WeakMap();\nconst key = { id: 1 };\ncache.set(key, largeData);\n// If key collected, entry removed automatically\n\n// Manual memory management NOT needed\n// GC handles it automatically'
    ),
    E'Garbage Collector:\n\n[Heap Memory]\n  [Obj A] ← ref1\n  [Obj B] ← ref2, ref3\n  [Obj C] ← (no refs) → GC collects\n  [Obj D] ← ref4\n\nGC Process:\n  1. Mark: Find reachable objects\n  2. Sweep: Collect unreachable\n  3. Compact: Defragment memory\n\nGenerations:\n  Gen 0: Young (frequent GC)\n  Gen 1: Middle\n  Gen 2: Old (rare GC)\n\nManaged: GC handles\nUnmanaged: YOU dispose (files, DB)',
    128
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'Garbage Collector does?', to_jsonb(ARRAY['Nothing', 'Automatically frees unused object memory', 'Manual delete', 'Compile code']), 1, 'Automatic memory management.'),
    (current_term_id, 'When object collected?', to_jsonb(ARRAY['Immediately', 'When no more references to it', 'Never', 'Random']), 1, 'Unreachable = eligible for GC.'),
    (current_term_id, 'Generations in .NET GC?', to_jsonb(ARRAY['No generations', 'Gen 0 (young), Gen 1, Gen 2 (old)', 'Only 1', '10 generations']), 1, 'Generational garbage collection.'),
    (current_term_id, 'IDisposable for?', to_jsonb(ARRAY['All objects', 'Unmanaged resources (files, connections)', 'Managed objects', 'Nothing']), 1, 'Explicit cleanup of unmanaged resources.'),
    (current_term_id, 'using statement does?', to_jsonb(ARRAY['Imports', 'Automatically calls Dispose()', 'Creates object', 'Deletes']), 1, 'Ensures Dispose() called.'),
    (current_term_id, 'Memory leak from?', to_jsonb(ARRAY['New objects', 'Event handlers not unsubscribed', 'GC', 'String']), 1, 'References prevent collection.'),
    (current_term_id, 'Should call GC.Collect()?', to_jsonb(ARRAY['Always', 'Rarely, let GC manage automatically', 'Every method', 'Required']), 1, 'GC knows best when to collect.');

  RAISE NOTICE 'Added String Immutability and Garbage Collector';
END $$;
