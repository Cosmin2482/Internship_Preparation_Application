/*
  # Add Advanced C# Concepts
  
  IEnumerable vs IQueryable, FirstOrDefault vs Single, var usage, readonly vs const
*/

DO $$
DECLARE
  cat_dotnet uuid;
  current_term_id uuid;
BEGIN
  SELECT id INTO cat_dotnet FROM categories WHERE slug = 'dotnet';

  -- IEnumerable vs IQueryable
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_dotnet, 'IEnumerable vs IQueryable',
    'IEnumerable = in-memory filtering (LINQ to Objects). IQueryable = database filtering (LINQ to SQL). IQueryable builds SQL query, IEnumerable filters in C#.',
    'IEnumerable: in-memory query execution, deferred but local. IQueryable: expression tree translated to query language (SQL), executed remotely. IQueryable extends IEnumerable.',
    'Use IQueryable for database queries - filters translated to SQL WHERE clause, efficient. IEnumerable loads all data then filters in memory - slow for large datasets. IQueryable builds expression tree, IEnumerable immediate execution after enumeration. IQueryable for EF Core queries, IEnumerable after ToList.',
    to_jsonb(ARRAY['Using IEnumerable for DB queries (loads everything)', 'Not understanding deferred execution', 'Multiple enumeration issues', 'Wrong type causing performance problems']),
    jsonb_build_object(
      'csharp', E'// IQueryable vs IEnumerable difference\n\n// IQueryable - Database filtering (EFFICIENT)\npublic async Task<List<User>> GetAdultUsersQueryable() {\n  IQueryable<User> query = _context.Users; // IQueryable\n  \n  query = query.Where(u => u.Age >= 18); // Builds expression tree\n  query = query.Where(u => u.IsActive);   // Adds to expression tree\n  \n  // SQL generated:\n  // SELECT * FROM Users WHERE Age >= 18 AND IsActive = 1\n  // Only adult active users loaded from database!\n  \n  return await query.ToListAsync(); // Execute SQL now\n}\n\n// IEnumerable - In-memory filtering (INEFFICIENT for DB)\npublic async Task<List<User>> GetAdultUsersEnumerable() {\n  IEnumerable<User> users = await _context.Users.ToListAsync();\n  // ⚠️ ALL users loaded into memory first!\n  \n  users = users.Where(u => u.Age >= 18); // Filters in C# (memory)\n  users = users.Where(u => u.IsActive);  // Filters in C# (memory)\n  \n  return users.ToList();\n  // Problem: Loaded 1 million users, filtered to 10k in memory!\n}\n\n// Real-world example\npublic async Task<List<Order>> GetRecentOrders(int userId) {\n  // GOOD - IQueryable (database filtering)\n  var recentOrders = await _context.Orders\n    .Where(o => o.UserId == userId)           // SQL WHERE\n    .Where(o => o.CreatedAt >= DateTime.Now.AddDays(-30)) // SQL WHERE\n    .OrderByDescending(o => o.CreatedAt)      // SQL ORDER BY\n    .Take(10)                                 // SQL TOP 10\n    .ToListAsync();\n  // SQL: SELECT TOP 10 * FROM Orders \n  //      WHERE UserId = @p0 AND CreatedAt >= @p1 \n  //      ORDER BY CreatedAt DESC\n  \n  return recentOrders;\n}\n\npublic async Task<List<Order>> GetRecentOrdersBad(int userId) {\n  // BAD - IEnumerable (loads everything)\n  var allOrders = await _context.Orders.ToListAsync(); // Load ALL orders!\n  \n  var recentOrders = allOrders\n    .Where(o => o.UserId == userId)     // Filter in C#\n    .Where(o => o.CreatedAt >= DateTime.Now.AddDays(-30)) // Filter in C#\n    .OrderByDescending(o => o.CreatedAt)\n    .Take(10)\n    .ToList();\n  // Loaded 1 million orders from DB, filtered in memory!\n  \n  return recentOrders;\n}\n\n// When to use each\n// IQueryable: Database queries (EF Core)\nIQueryable<User> dbQuery = _context.Users.Where(u => u.IsActive);\n\n// IEnumerable: In-memory collections\nvar list = new List<int> { 1, 2, 3, 4, 5 };\nIEnumerable<int> memoryQuery = list.Where(x => x > 2);\n\n// IEnumerable: After data already loaded\nvar users = await _context.Users.ToListAsync(); // Now in memory\nIEnumerable<User> filtered = users.Where(u => u.Name.StartsWith("J"));\n\n// Deferred execution example\nIQueryable<User> query = _context.Users.Where(u => u.Age > 18);\n// No database call yet!\n\nquery = query.OrderBy(u => u.Name);\n// Still no database call!\n\nvar result = await query.ToListAsync();\n// NOW database executes: SELECT * FROM Users WHERE Age > 18 ORDER BY Name',
      'typescript', E'// JavaScript/TypeScript does not have IQueryable concept\n// But understanding deferred vs eager execution matters\n\n// Eager execution (like IEnumerable after ToList)\nconst users = await db.users.findAll(); // Load ALL\nconst adults = users.filter(u => u.age >= 18); // Filter in memory\n\n// Lazy execution (like IQueryable)\nconst adults = await db.users.findAll({\n  where: { age: { gte: 18 } } // Filter in database\n});\n\n// ORMs like Prisma/TypeORM build queries similar to IQueryable\nconst query = db.user\n  .where({ age: { gte: 18 } })  // Builds query\n  .orderBy({ name: ''asc'' });   // Adds to query\n  \nconst result = await query.exec(); // Execute now'
    ),
    E'IQueryable vs IEnumerable:\n\nIQueryable (Database):\n  query.Where(x => x.Age > 18)\n       ↓\n  Expression Tree\n       ↓\n  SQL: WHERE Age > 18\n       ↓\n  Database filters\n       ↓\n  Return only matches\n  EFFICIENT ✓\n\nIEnumerable (Memory):\n  query.ToList() // Load ALL\n       ↓\n  All data in memory\n       ↓\n  .Where(x => x.Age > 18)\n       ↓\n  C# filters in memory\n  SLOW for large data ✗\n\nRule: IQueryable for DB queries',
    50
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'IQueryable filters?', to_jsonb(ARRAY['In memory', 'In database via SQL', 'Client-side', 'Not at all']), 1, 'Translates to SQL WHERE clause.'),
    (current_term_id, 'IEnumerable filters?', to_jsonb(ARRAY['In database', 'In memory after loading data', 'Never', 'Server-side']), 1, 'Filters loaded data in C#.'),
    (current_term_id, 'For EF Core queries use?', to_jsonb(ARRAY['IEnumerable', 'IQueryable', 'List', 'Array']), 1, 'Efficient database filtering.'),
    (current_term_id, 'IQueryable advantage?', to_jsonb(ARRAY['Slower', 'Only loads filtered data from DB', 'Loads everything', 'No advantage']), 1, 'Efficient for large datasets.'),
    (current_term_id, 'When use IEnumerable?', to_jsonb(ARRAY['Database queries', 'In-memory collections or after ToList', 'Always', 'Never']), 1, 'After data already loaded.');

  -- FirstOrDefault vs Single
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_dotnet, 'FirstOrDefault vs Single vs SingleOrDefault',
    'FirstOrDefault = first or null, ok with multiple. Single = exactly one or exception. SingleOrDefault = one or null, exception if multiple.',
    'FirstOrDefault: returns first element or default, does not care about count. Single: expects exactly one, throws if zero or multiple. SingleOrDefault: expects zero or one, throws if multiple.',
    'Use FirstOrDefault when you want first match and do not care if more exist. Single when you expect exactly one (throws if not). SingleOrDefault when you expect zero or one (throws if multiple). Single/SingleOrDefault enforce uniqueness assumption.',
    to_jsonb(ARRAY['Using Single when multiple possible', 'Not null checking FirstOrDefault', 'Using First without OrDefault', 'Wrong choice causing exceptions', 'Performance difference ignored']),
    jsonb_build_object(
      'csharp', E'// FirstOrDefault vs Single vs SingleOrDefault\n\n// FIRSTORDEFAULT - Returns first or default (null for reference types)\npublic async Task<User?> GetUserByEmail(string email) {\n  // Ok if multiple users with same email (returns first)\n  // Ok if no users (returns null)\n  var user = await _context.Users\n    .FirstOrDefaultAsync(u => u.Email == email);\n  \n  if(user == null) {\n    // Handle not found\n    return null;\n  }\n  return user;\n}\n\n// Use FirstOrDefault when:\n// - You want first match\n// - Don\'t care if more exist\n// - Want null if none found\n\n// SINGLE - Expects EXACTLY one, throws otherwise\npublic async Task<User> GetUserById(int id) {\n  // Throws if 0 users (InvalidOperationException)\n  // Throws if >1 users (InvalidOperationException)\n  // Only returns if EXACTLY 1\n  var user = await _context.Users.SingleAsync(u => u.Id == id);\n  // Assumption: Id is primary key, so exactly one exists\n  return user;\n}\n\n// Use Single when:\n// - You EXPECT exactly one\n// - Want to catch data integrity issues\n// - Uniqueness constraint in business logic\n\n// SINGLEORDEFAULT - Expects 0 or 1, throws if multiple\npublic async Task<UserProfile?> GetProfileByUserId(int userId) {\n  // Ok if 0 profiles (returns null)\n  // Ok if 1 profile (returns it)\n  // Throws if >1 profiles (InvalidOperationException - data corruption!)\n  var profile = await _context.UserProfiles\n    .SingleOrDefaultAsync(p => p.UserId == userId);\n  \n  // Assumption: One-to-one relationship\n  return profile;\n}\n\n// Use SingleOrDefault when:\n// - You expect 0 or 1\n// - Want null if none\n// - Want exception if multiple (data error)\n\n// Examples with results\nvar users = new List<User> {\n  new User { Id = 1, Email = "john@test.com" },\n  new User { Id = 2, Email = "john@test.com" }, // Duplicate email!\n  new User { Id = 3, Email = "jane@test.com" }\n};\n\n// FirstOrDefault with duplicates\nvar first = users.FirstOrDefault(u => u.Email == "john@test.com");\n// Returns: User with Id=1 (first match, ignores Id=2)\n\nvar firstNone = users.FirstOrDefault(u => u.Email == "none@test.com");\n// Returns: null (no match)\n\n// Single with duplicates\ntry {\n  var single = users.Single(u => u.Email == "john@test.com");\n  // Throws: InvalidOperationException\n  // "Sequence contains more than one element"\n} catch(InvalidOperationException ex) {\n  // Handle error - data integrity issue!\n}\n\n// Single with unique\nvar singleUnique = users.Single(u => u.Email == "jane@test.com");\n// Returns: User with Id=3 (exactly one match)\n\n// Single with none\ntry {\n  var singleNone = users.Single(u => u.Email == "none@test.com");\n  // Throws: InvalidOperationException\n  // "Sequence contains no elements"\n} catch(InvalidOperationException ex) {\n  // Handle not found\n}\n\n// SingleOrDefault with unique\nvar singleOrDefault = users.SingleOrDefault(u => u.Email == "jane@test.com");\n// Returns: User with Id=3\n\n// SingleOrDefault with none\nvar singleOrDefaultNone = users.SingleOrDefault(u => u.Email == "none@test.com");\n// Returns: null (no match, ok)\n\n// SingleOrDefault with duplicates\ntry {\n  var singleOrDefaultDup = users.SingleOrDefault(u => u.Email == "john@test.com");\n  // Throws: InvalidOperationException\n  // "Sequence contains more than one element"\n} catch(InvalidOperationException ex) {\n  // Data corruption detected!\n}\n\n// Performance consideration\n// FirstOrDefault: Can stop after finding first (fast)\nvar firstFast = _context.Users\n  .Where(u => u.IsActive)\n  .FirstOrDefaultAsync();\n// SQL: SELECT TOP 1 * FROM Users WHERE IsActive = 1\n\n// Single/SingleOrDefault: Must check entire sequence (slower)\nvar singleSlow = _context.Users\n  .Where(u => u.IsActive)\n  .SingleAsync();\n// SQL: SELECT * FROM Users WHERE IsActive = 1\n// Then checks count in memory - if != 1, throws',
      'typescript', E'// JavaScript/TypeScript equivalents\n\nconst users = [\n  { id: 1, email: "john@test.com" },\n  { id: 2, email: "john@test.com" },\n  { id: 3, email: "jane@test.com" }\n];\n\n// FirstOrDefault equivalent\nconst first = users.find(u => u.email === "john@test.com");\n// Returns: { id: 1, ... } (first match)\n\nconst firstNone = users.find(u => u.email === "none@test.com");\n// Returns: undefined (no match)\n\n// Single equivalent (manual)\nfunction single<T>(arr: T[], predicate: (item: T) => boolean): T {\n  const matches = arr.filter(predicate);\n  if(matches.length === 0) throw new Error("No elements");\n  if(matches.length > 1) throw new Error("Multiple elements");\n  return matches[0];\n}\n\ntry {\n  const singleUser = single(users, u => u.email === "john@test.com");\n  // Throws: "Multiple elements"\n} catch(error) {\n  console.error(error);\n}\n\nconst singleUnique = single(users, u => u.email === "jane@test.com");\n// Returns: { id: 3, ... }'
    ),
    E'FirstOrDefault vs Single:\n\nData: [A, B, C, C]\n\nFirstOrDefault(x => x == C):\n  → Returns C (first)\n  Ok with multiple\n  \nSingle(x => x == C):\n  → Throws! (multiple)\n  Expects exactly 1\n  \nSingleOrDefault(x => x == C):\n  → Throws! (multiple)\n  Expects 0 or 1\n\nData: [A, B]\n\nFirstOrDefault(x => x == Z):\n  → null\n  \nSingle(x => x == Z):\n  → Throws! (none)\n  \nSingleOrDefault(x => x == Z):\n  → null (ok)',
    51
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'FirstOrDefault with multiple matches?', to_jsonb(ARRAY['Throws exception', 'Returns first', 'Returns all', 'Returns null']), 1, 'Returns first, ignores rest.'),
    (current_term_id, 'Single with multiple matches?', to_jsonb(ARRAY['Returns first', 'Throws InvalidOperationException', 'Returns all', 'Returns null']), 1, 'Expects exactly one.'),
    (current_term_id, 'SingleOrDefault with multiple matches?', to_jsonb(ARRAY['Returns first', 'Throws InvalidOperationException', 'Returns null', 'Returns all']), 1, 'Expects 0 or 1, not multiple.'),
    (current_term_id, 'When use Single?', to_jsonb(ARRAY['Want first', 'Expect exactly one enforce uniqueness', 'Multiple ok', 'Never']), 1, 'Primary key lookups, unique constraints.'),
    (current_term_id, 'FirstOrDefault with no matches?', to_jsonb(ARRAY['Throws', 'Returns null/default', 'Returns empty', 'Crashes']), 1, 'Safe, returns null.'),
    (current_term_id, 'Single with no matches?', to_jsonb(ARRAY['Returns null', 'Throws InvalidOperationException', 'Returns first', 'Ok']), 1, 'Expects at least one.'),
    (current_term_id, 'Performance: FirstOrDefault vs Single?', to_jsonb(ARRAY['Same', 'FirstOrDefault faster (can stop early)', 'Single faster', 'No difference']), 1, 'First stops after finding one.');

  RAISE NOTICE 'Added advanced C# concepts';
END $$;
