/*
  # Add Advanced HTTP Concepts
  
  Deep explanations for: PUT vs PATCH, Idempotency, 401 vs 403, Safe Methods, String Immutability
*/

DO $$
DECLARE
  cat_arch uuid;
  cat_oop uuid;
  current_term_id uuid;
BEGIN
  SELECT id INTO cat_arch FROM categories WHERE slug = 'architecture';
  SELECT id INTO cat_oop FROM categories WHERE slug = 'oop';

  -- PUT vs PATCH
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_arch, 'PUT vs PATCH (Update Operations)',
    'PUT = replace ENTIRE resource. PATCH = update ONLY specific fields. PUT sends all data, PATCH sends only changes.',
    'PUT: idempotent, replaces entire resource with provided representation. PATCH: partially updates resource, only specified fields changed.',
    'PUT for complete replacement: send all fields, missing fields become null/default. PATCH for partial update: send only changed fields. PUT idempotent (same result repeated), PATCH may not be. Use PATCH when resource large and only few fields change.',
    to_jsonb(ARRAY['Using PUT for partial updates', 'PATCH not supported by all APIs', 'Not understanding idempotency difference', 'Sending partial data with PUT (loses fields)', 'PATCH without proper merge logic']),
    jsonb_build_object(
      'csharp', E'// User model\npublic class User {\n  public int Id { get; set; }\n  public string Name { get; set; }\n  public string Email { get; set; }\n  public int Age { get; set; }\n  public string Phone { get; set; }\n}\n\n// Current user in database:\n// { id: 1, name: "John", email: "john@example.com", age: 30, phone: "123-456" }\n\n// PUT /api/users/1 - REPLACE ENTIRE RESOURCE\n[HttpPut("{id}")]\npublic async Task<IActionResult> Put(int id, User user) {\n  // Client MUST send ALL fields\n  // Request body:\n  // {\n  //   "id": 1,\n  //   "name": "John Doe",\n  //   "email": "john@example.com",\n  //   "age": 31,\n  //   "phone": "123-456"\n  // }\n  \n  var existing = await _context.Users.FindAsync(id);\n  if(existing == null) return NotFound();\n  \n  // Replace ALL fields\n  existing.Name = user.Name;\n  existing.Email = user.Email;\n  existing.Age = user.Age;\n  existing.Phone = user.Phone;\n  \n  await _context.SaveChangesAsync();\n  return NoContent(); // 204\n}\n\n// If client sends incomplete data with PUT:\n// {\n//   "id": 1,\n//   "name": "John Doe",\n//   "age": 31\n// }\n// Result: email and phone become NULL! (BAD)\n\n// PATCH /api/users/1 - UPDATE ONLY SPECIFIED FIELDS\n[HttpPatch("{id}")]\npublic async Task<IActionResult> Patch(int id, JsonPatchDocument<User> patch) {\n  // Client sends ONLY changed fields\n  // Request body:\n  // [\n  //   { "op": "replace", "path": "/age", "value": 31 },\n  //   { "op": "replace", "path": "/name", "value": "John Doe" }\n  // ]\n  \n  var existing = await _context.Users.FindAsync(id);\n  if(existing == null) return NotFound();\n  \n  patch.ApplyTo(existing); // Apply only specified changes\n  \n  await _context.SaveChangesAsync();\n  return NoContent(); // 204\n  \n  // Result: Only age and name changed, email and phone untouched!\n}\n\n// Simple PATCH (without JSON Patch)\n[HttpPatch("{id}/simple")]\npublic async Task<IActionResult> PatchSimple(int id, UserPatchDto patch) {\n  var user = await _context.Users.FindAsync(id);\n  if(user == null) return NotFound();\n  \n  // Update only non-null fields\n  if(patch.Name != null) user.Name = patch.Name;\n  if(patch.Age.HasValue) user.Age = patch.Age.Value;\n  if(patch.Email != null) user.Email = patch.Email;\n  // phone NOT sent, so unchanged\n  \n  await _context.SaveChangesAsync();\n  return Ok(user);\n}\n\npublic class UserPatchDto {\n  public string? Name { get; set; }\n  public int? Age { get; set; }\n  public string? Email { get; set; }\n  // Note: nullable types - only update if provided\n}',
      'typescript', E'// Current user:\n// { id: 1, name: "John", email: "john@example.com", age: 30, phone: "123-456" }\n\n// PUT - Replace entire resource\nconst putUpdate = await fetch(''https://api.example.com/api/users/1'', {\n  method: ''PUT'',\n  headers: { ''Content-Type'': ''application/json'' },\n  body: JSON.stringify({\n    id: 1,\n    name: "John Doe",\n    email: "john@example.com",\n    age: 31,\n    phone: "123-456"\n  }) // MUST send ALL fields!\n});\n// Result: ALL fields replaced\n\n// PUT with missing fields (BAD)\nconst incompletePut = await fetch(''https://api.example.com/api/users/1'', {\n  method: ''PUT'',\n  body: JSON.stringify({\n    name: "John Doe",\n    age: 31\n  }) // Missing email and phone!\n});\n// Result: email and phone become null/undefined! Data loss!\n\n// PATCH - Partial update (only changed fields)\nconst patchUpdate = await fetch(''https://api.example.com/api/users/1'', {\n  method: ''PATCH'',\n  headers: { ''Content-Type'': ''application/json'' },\n  body: JSON.stringify({\n    age: 31,\n    name: "John Doe"\n  }) // Only fields to change\n});\n// Result: ONLY age and name updated, email and phone unchanged!\n\n// Server-side handling (Express)\napp.patch(''/api/users/:id'', async (req, res) => {\n  const user = await db.users.findById(req.params.id);\n  \n  // Update only provided fields\n  if(req.body.name !== undefined) user.name = req.body.name;\n  if(req.body.age !== undefined) user.age = req.body.age;\n  if(req.body.email !== undefined) user.email = req.body.email;\n  // phone not in body, so unchanged\n  \n  await user.save();\n  res.json(user);\n});\n\napp.put(''/api/users/:id'', async (req, res) => {\n  const user = await db.users.findById(req.params.id);\n  \n  // Replace ALL fields\n  user.name = req.body.name;\n  user.email = req.body.email;\n  user.age = req.body.age;\n  user.phone = req.body.phone;\n  // If any missing from body, becomes null!\n  \n  await user.save();\n  res.json(user);\n});'
    ),
    E'PUT vs PATCH:\n\nPUT (Replace):\n  Client sends: ALL fields\n  Server: Replaces entire resource\n  Missing fields → null/default\n  Idempotent: ✓\n  \n  PUT /users/1\n  {name, email, age, phone} → Replace all\n\nPATCH (Update):\n  Client sends: ONLY changed fields\n  Server: Updates specified fields\n  Missing fields → unchanged\n  Idempotent: maybe\n  \n  PATCH /users/1\n  {age: 31} → Only age updated\n\nUse PATCH for large resources',
    72
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'PUT does?', to_jsonb(ARRAY['Partial update', 'Replaces entire resource', 'Deletes', 'Creates']), 1, 'Complete replacement.'),
    (current_term_id, 'PATCH does?', to_jsonb(ARRAY['Replaces all', 'Partially updates specified fields', 'Deletes', 'Creates']), 1, 'Only changed fields.'),
    (current_term_id, 'PUT with missing fields?', to_jsonb(ARRAY['Keeps old values', 'Sets missing to null/default (data loss)', 'Error', 'Ignores']), 1, 'Dangerous if incomplete!'),
    (current_term_id, 'PATCH advantage?', to_jsonb(ARRAY['Slower', 'Less data sent, preserves unchanged fields', 'More complex', 'No advantage']), 1, 'Efficient for large resources.'),
    (current_term_id, 'When use PUT?', to_jsonb(ARRAY['Always', 'Complete replacement with all fields', 'Partial updates', 'Delete']), 1, 'Full resource update.');

  -- Idempotency
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_arch, 'Idempotency in HTTP',
    'Idempotent = calling same operation multiple times has same effect as calling once. GET, PUT, DELETE idempotent. POST not idempotent.',
    'Idempotent operation: making multiple identical requests has same effect as single request. Critical for reliability in distributed systems.',
    'GET, PUT, DELETE, HEAD, OPTIONS are idempotent. Calling twice = same result. POST NOT idempotent (creates new resource each time). PATCH may/may not be. Idempotency important for retries - if network fails, safe to retry idempotent operations.',
    to_jsonb(ARRAY['Thinking POST idempotent', 'Not implementing idempotency keys', 'Side effects in GET', 'Not understanding retry safety', 'PATCH assumed idempotent']),
    jsonb_build_object(
      'csharp', E'// IDEMPOTENT: GET (Safe + Idempotent)\n[HttpGet("{id}")]\npublic async Task<IActionResult> Get(int id) {\n  var user = await _context.Users.FindAsync(id);\n  return Ok(user);\n}\n// Call 1: Returns user 123\n// Call 2: Returns user 123 (SAME result)\n// Call 100: Returns user 123 (SAME result)\n// No changes to server state!\n\n// IDEMPOTENT: PUT\n[HttpPut("{id}")]\npublic async Task<IActionResult> Put(int id, User user) {\n  var existing = await _context.Users.FindAsync(id);\n  existing.Name = "John Doe";\n  existing.Age = 30;\n  await _context.SaveChangesAsync();\n  return NoContent();\n}\n// Call 1: Sets name="John Doe", age=30\n// Call 2: Sets name="John Doe", age=30 (SAME state)\n// Call 10: Sets name="John Doe", age=30 (SAME state)\n// Result identical no matter how many times called!\n\n// IDEMPOTENT: DELETE\n[HttpDelete("{id}")]\npublic async Task<IActionResult> Delete(int id) {\n  var user = await _context.Users.FindAsync(id);\n  if(user == null) return NotFound(); // Already deleted\n  \n  _context.Users.Remove(user);\n  await _context.SaveChangesAsync();\n  return NoContent();\n}\n// Call 1: Deletes user (204)\n// Call 2: User not found (404) - but resource still deleted\n// Call 3: User not found (404) - end state same\n// Safe to retry!\n\n// NOT IDEMPOTENT: POST\n[HttpPost]\npublic async Task<IActionResult> Post(User user) {\n  _context.Users.Add(user);\n  await _context.SaveChangesAsync();\n  return CreatedAtAction(nameof(Get), new { id = user.Id }, user);\n}\n// Call 1: Creates user with ID 1\n// Call 2: Creates ANOTHER user with ID 2 (DIFFERENT!)\n// Call 3: Creates ANOTHER user with ID 3 (DIFFERENT!)\n// Each call creates new resource - NOT idempotent\n// Dangerous to retry without idempotency key!\n\n// Making POST idempotent with idempotency key\n[HttpPost]\npublic async Task<IActionResult> PostIdempotent(\n  [FromHeader(Name = "Idempotency-Key")] string idempotencyKey,\n  User user) {\n  \n  // Check if already processed\n  var existing = await _context.IdempotencyKeys\n    .FirstOrDefaultAsync(k => k.Key == idempotencyKey);\n  \n  if(existing != null) {\n    // Already processed - return same result\n    var existingUser = await _context.Users.FindAsync(existing.ResourceId);\n    return Ok(existingUser); // Idempotent!\n  }\n  \n  // New request - process\n  _context.Users.Add(user);\n  await _context.SaveChangesAsync();\n  \n  // Store idempotency key\n  _context.IdempotencyKeys.Add(new IdempotencyRecord {\n    Key = idempotencyKey,\n    ResourceId = user.Id\n  });\n  await _context.SaveChangesAsync();\n  \n  return CreatedAtAction(nameof(Get), new { id = user.Id }, user);\n}\n\n// NOT IDEMPOTENT: PATCH (increment)\n[HttpPatch("{id}/increment-age")]\npublic async Task<IActionResult> IncrementAge(int id) {\n  var user = await _context.Users.FindAsync(id);\n  user.Age++; // Increment!\n  await _context.SaveChangesAsync();\n  return Ok(user);\n}\n// Call 1: age = 31\n// Call 2: age = 32 (DIFFERENT!)\n// Call 3: age = 33 (DIFFERENT!)\n// NOT idempotent - each call changes result',
      'typescript', E'// IDEMPOTENT: GET\napp.get(''/users/:id'', async (req, res) => {\n  const user = await db.users.findById(req.params.id);\n  res.json(user);\n});\n// Multiple calls: same user returned, no changes\n\n// IDEMPOTENT: PUT\napp.put(''/users/:id'', async (req, res) => {\n  const user = await db.users.findById(req.params.id);\n  user.name = "John Doe";\n  user.age = 30;\n  await user.save();\n  res.json(user);\n});\n// Multiple calls: same final state (name="John Doe", age=30)\n\n// IDEMPOTENT: DELETE\napp.delete(''/users/:id'', async (req, res) => {\n  const result = await db.users.deleteById(req.params.id);\n  if(!result) return res.status(404).json({ error: ''Not found'' });\n  res.status(204).send();\n});\n// Call 1: deletes (204)\n// Call 2+: 404, but resource still deleted\n\n// NOT IDEMPOTENT: POST\napp.post(''/users'', async (req, res) => {\n  const user = await db.users.create(req.body);\n  res.status(201).json(user);\n});\n// Each call creates NEW user - NOT idempotent\n\n// POST with idempotency key\napp.post(''/users'', async (req, res) => {\n  const idempotencyKey = req.headers[''idempotency-key''];\n  \n  // Check cache\n  const cached = await redis.get(idempotencyKey);\n  if(cached) {\n    return res.json(JSON.parse(cached)); // Same result!\n  }\n  \n  // Process\n  const user = await db.users.create(req.body);\n  \n  // Store result\n  await redis.set(idempotencyKey, JSON.stringify(user), ''EX'', 86400);\n  \n  res.status(201).json(user);\n});\n\n// NOT IDEMPOTENT: PATCH increment\napp.patch(''/users/:id/increment-score'', async (req, res) => {\n  const user = await db.users.findById(req.params.id);\n  user.score += 1; // Each call increases!\n  await user.save();\n  res.json(user);\n});\n// Call 1: score=11, Call 2: score=12, Call 3: score=13'
    ),
    E'Idempotency:\n\nIdempotent Methods:\n  GET    → Same data\n  PUT    → Same final state\n  DELETE → Same result (deleted)\n  HEAD, OPTIONS → Same\n  \nCall once or 100 times = SAME result\nSafe to retry!\n\nNOT Idempotent:\n  POST   → Creates NEW each time\n  PATCH  → May modify differently\n  \nDangerous to retry without idempotency key\n\nIdempotency Key pattern:\n  Client sends: Idempotency-Key header\n  Server: Caches result\n  Retry: Returns cached result',
    73
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, 'Idempotent means?', to_jsonb(ARRAY['Fast', 'Multiple calls = same result', 'Single call only', 'Always fails']), 1, 'Same effect if repeated.'),
    (current_term_id, 'GET is idempotent?', to_jsonb(ARRAY['Yes', 'No', 'Sometimes', 'Depends']), 0, 'Read operation, no state change.'),
    (current_term_id, 'POST is idempotent?', to_jsonb(ARRAY['Yes', 'No, creates new resource each time', 'Always', 'Usually']), 1, 'Each call creates new.'),
    (current_term_id, 'PUT is idempotent?', to_jsonb(ARRAY['Yes, same final state', 'No', 'Sometimes', 'Never']), 0, 'Replaces to same state.'),
    (current_term_id, 'DELETE is idempotent?', to_jsonb(ARRAY['Yes, resource stays deleted', 'No', 'Maybe', 'Never']), 0, 'End result same: deleted.'),
    (current_term_id, 'Why idempotency important?', to_jsonb(ARRAY['Speed', 'Safe to retry on network failures', 'Required', 'No reason']), 1, 'Reliability in distributed systems.'),
    (current_term_id, 'Make POST idempotent?', to_jsonb(ARRAY['Impossible', 'Use Idempotency-Key header', 'Use GET', 'Use PUT']), 1, 'Client-provided unique key.');

  -- 401 vs 403
  INSERT INTO terms (category_id, term, eli5, formal_definition, interview_answer, pitfalls, code_examples, diagram, order_index)
  VALUES (
    cat_arch, '401 Unauthorized vs 403 Forbidden',
    '401 = "Who are you?" (not logged in). 403 = "I know who you are, but you can''t do that" (logged in, but no permission).',
    '401 Unauthorized: authentication required or failed. 403 Forbidden: authenticated but lacks authorization for resource.',
    '401: You need to login first. Send credentials or token. 403: You are logged in, but don''t have permission for this resource. User vs admin, different access levels. 401 can be fixed by authenticating, 403 cannot without changing permissions.',
    to_jsonb(ARRAY['Confusing authentication with authorization', 'Using wrong status code', 'Not understanding difference', '403 when should be 401', 'Exposing too much info in 403']),
    jsonb_build_object(
      'csharp', E'// 401 UNAUTHORIZED - Not authenticated\n[HttpGet("protected")]\n[Authorize] // Requires authentication\npublic IActionResult Protected() {\n  return Ok("Protected data");\n}\n\n// Request WITHOUT token:\n// GET /api/protected\n// Response: 401 Unauthorized\n// {\n//   "error": "Authentication required. Please login."\n// }\n\n// Custom 401 handling\n[HttpGet("profile")]\npublic IActionResult GetProfile() {\n  var token = Request.Headers["Authorization"].ToString();\n  \n  if(string.IsNullOrEmpty(token)) {\n    return Unauthorized(new { // 401\n      error = "No token provided",\n      message = "Please login to access this resource"\n    });\n  }\n  \n  var user = ValidateToken(token);\n  if(user == null) {\n    return Unauthorized(new { // 401\n      error = "Invalid token",\n      message = "Token expired or invalid. Please login again."\n    });\n  }\n  \n  return Ok(user);\n}\n\n// 403 FORBIDDEN - Authenticated but not authorized\n[HttpDelete("users/{id}")]\n[Authorize] // Must be logged in\npublic async Task<IActionResult> DeleteUser(int id) {\n  var currentUser = GetCurrentUser(); // From JWT\n  var targetUser = await _context.Users.FindAsync(id);\n  \n  // User IS authenticated (passed [Authorize])\n  // But check if user has permission\n  if(currentUser.Role != "Admin") {\n    return Forbid(); // 403 Forbidden\n    // Or with message:\n    // return StatusCode(403, new {\n    //   error = "Forbidden",\n    //   message = "Only admins can delete users"\n    // });\n  }\n  \n  // User is admin - proceed\n  _context.Users.Remove(targetUser);\n  await _context.SaveChangesAsync();\n  return NoContent();\n}\n\n// Another 403 example: resource ownership\n[HttpPut("orders/{id}")]\n[Authorize]\npublic async Task<IActionResult> UpdateOrder(int id, Order order) {\n  var currentUser = GetCurrentUser();\n  var existingOrder = await _context.Orders.FindAsync(id);\n  \n  // User authenticated, but not their order\n  if(existingOrder.UserId != currentUser.Id && currentUser.Role != "Admin") {\n    return Forbid(); // 403 - Can\'t edit someone else\'s order\n  }\n  \n  // User owns the order or is admin - proceed\n  existingOrder.Status = order.Status;\n  await _context.SaveChangesAsync();\n  return Ok(existingOrder);\n}\n\n// Authorization attribute for roles\n[HttpPost("admin/reports")]\n[Authorize(Roles = "Admin")] // Only Admin role\npublic IActionResult CreateReport() {\n  // If user not Admin → 403 Forbidden automatically\n  return Ok("Report created");\n}',
      'typescript', E'// Middleware for authentication\napp.use(''/api/*'', (req, res, next) => {\n  const token = req.headers.authorization?.split('' '')[1];\n  \n  if(!token) {\n    return res.status(401).json({ // 401 Unauthorized\n      error: ''Authentication required'',\n      message: ''Please provide a valid token''\n    });\n  }\n  \n  const user = verifyToken(token);\n  if(!user) {\n    return res.status(401).json({ // 401 Unauthorized\n      error: ''Invalid token'',\n      message: ''Token expired or invalid''\n    });\n  }\n  \n  req.user = user; // Attach to request\n  next();\n});\n\n// 403 FORBIDDEN - Authenticated but no permission\napp.delete(''/api/users/:id'', (req, res) => {\n  // User IS authenticated (passed middleware)\n  \n  if(req.user.role !== ''admin'') {\n    return res.status(403).json({ // 403 Forbidden\n      error: ''Forbidden'',\n      message: ''Only admins can delete users''\n    });\n  }\n  \n  // User is admin - proceed\n  db.users.delete(req.params.id);\n  res.status(204).send();\n});\n\n// 403 example: resource ownership\napp.put(''/api/posts/:id'', async (req, res) => {\n  const post = await db.posts.findById(req.params.id);\n  \n  // User authenticated, but doesn''t own post\n  if(post.authorId !== req.user.id && req.user.role !== ''admin'') {\n    return res.status(403).json({ // 403 Forbidden\n      error: ''Forbidden'',\n      message: ''You can only edit your own posts''\n    });\n  }\n  \n  // User owns post or is admin - proceed\n  await post.update(req.body);\n  res.json(post);\n});\n\n// Summary:\n// 401: No token, invalid token, expired token\n// 403: Valid token, but wrong role/permission'
    ),
    E'401 vs 403:\n\n401 Unauthorized:\n  "Who are you?"\n  Not logged in / No token\n  Invalid/expired token\n  Fix: Login, get valid token\n  \n  [User] → [API]\n           ↓\n         401: Login required!\n\n403 Forbidden:\n  "I know you, but NO"\n  Logged in ✓\n  Wrong role/permission ✗\n  Can''t fix without permission change\n  \n  [Regular User] → [Admin Endpoint]\n                      ↓\n                    403: Admins only!\n\nAuthentication ≠ Authorization',
    74
  ) RETURNING id INTO current_term_id;
  
  INSERT INTO quiz_questions (term_id, question, choices, correct_index, explanation)
  VALUES
    (current_term_id, '401 means?', to_jsonb(ARRAY['No permission', 'Not authenticated (not logged in)', 'Server error', 'Not found']), 1, 'Need to login.'),
    (current_term_id, '403 means?', to_jsonb(ARRAY['Not logged in', 'Authenticated but not authorized', 'Server error', 'Success']), 1, 'Logged in, but no permission.'),
    (current_term_id, 'No token sent?', to_jsonb(ARRAY['403', '401 Unauthorized', '404', '500']), 1, 'Authentication required.'),
    (current_term_id, 'User logged in, tries admin endpoint?', to_jsonb(ARRAY['401', '403 Forbidden', '200', '404']), 1, 'Authenticated but not admin.'),
    (current_term_id, 'Can fix 401?', to_jsonb(ARRAY['No', 'Yes, by logging in with valid credentials', 'Maybe', 'Impossible']), 1, 'Provide valid token.'),
    (current_term_id, 'Can fix 403?', to_jsonb(ARRAY['Yes easily', 'No, need permission/role change', 'By logging out', 'By retrying']), 1, 'Authorization issue, need different permissions.');

  RAISE NOTICE 'Added advanced HTTP concepts';
END $$;
